\documentclass{scrartcl}
\KOMAoptions
  {
    fontsize=12pt,
    paper=a4,
    pagesize=pdftex,
    DIV=calc,
    headings=standardclasses,
    headings=small,
    twoside=on,
    BCOR=1cm
  }
  
\usepackage{adrianschneider}
\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Langevin}{L}
\newcommand{\He}{H_\text{e}}
\newcommand{\Man}{M_\text{an}}
\newcommand{\Msat}{M_\text{sat}}
\newcommand{\Mirr}{M_\text{irr}}
\newcommand{\Mrev}{M_\text{rev}}
\newcommand{\textref}[1]{\text{(\ref{#1})}}
\newcommand{\eqr}[1]{\underset{\textref{#1}}{=}}
  
\addbibresource{theory.bib}
\begin{document}

\tableofcontents
\newpage
\section{Einleitung}
\subsection{Zielsetzung}
Ziel des Projektes ist es, die Kernverluste in induktiven Bauelementen besser vorhersagen zu können als mit den bisherigen Methoden. Das typische Vorgehen bei der Abschätzung dieser Verluste basiert derzeit meist auf der Steinmetz-Formel bzw. auf ihren Erweiterungen. Diese beschreibt rein phänomenologisch die Verluste abhängig von Flussdichte, Frequenz und Temperatur. Dabei wird jedoch weder die Stromform noch die Kernform einbezogen.\\
\subsection{Hysteresemodelle}
Um hier eine Verbesserung erzielen zu können, ist es notwendig, die Hysterese transient zu beschreiben und mit diesem Modell die Verluste zu berechnen. Die Wissenschaft hat hierfür einige Modelle hervorgebracht:
\begin{labeling}{Krasnosel’skii–Pokrovskii}
	\item[Komplexe Permeabilität]{}
	\item[Jiles-Atherton]{}
	\item[Preisach]{}
	\item[Coleman-Hodgdon]{}
	\item[Krasnosel’skii–Pokrovskii]{}
	\item[Maxwell-Slip]{}
	\item[Bouc–Wen]{}
	\item[Duhem]{}
	\item[VINCH]{}
\end{labeling}
Die verschiednen Modelle unterscheiden sich insbesondere in der Anzahl der Modellparameter. Während das Jiles-Atherton mit fünf Parametern auskommt, können etwa im Preisach oder VINCH-Modell beliebig viele Parameter eingeführt werden -- dies führt dazu, dass gemessene Hysteresekurven genauer angenähert werden können, jedoch vermutlich die Allgemeingültigkeit ein Stück weit verloren geht.\\
Ein entscheidendes Problem bei fast allen erwähnten Modellen ist die Parameteridentifikation -- die Modellparameter müssen an Messkurven angeglichen werden. Bei dem Modell der komplexen Permeabilität fällt dies noch recht leicht, da hier einer einfachen Leistungsmessung ausreicht (noch dazu ist das Modell linear). Für die anderen Modelle, die alle nichtlinear sind, gestaltet sich dies jedoch deutlich schwieriger.
\subsection{Parameteridentifikation}
Das übliche Vorgehen ist, eine Kostenfunktion aufzustellen, die ihr Minimum dann annimmt, wenn Messdaten und Simulationsdaten am besten übereinstimmen. Diese Kostenfunktion muss anschließend mit einem geeigneten Algorithmus minimiert werden. Für nichtlineare Modelle wie die vorliegenden gestaltet sich dies jedoch oft sehr schwierig -- die meisten Algorithmen benötigen für eine schnelle Konvergenz die Jacobi- oder sogar auch die Hesse-Matrix der zu minimierenden Kostenfunktion. Diese sind analytisch jedoch nicht zugänglich. Ein alternativer Ansatz ist, gradientenfreie Algorithmen zu verwenden (genetische Algorithmen, linear Programming etc.). Dies wurde in der Literatur auch wiederholt vorgenommen -- die Konvergenz kann hierbei jedoch nicht garantiert werden, noch dazu sind diese Algorithmen recht langsam.
\subsection{Automatisches Differenzieren}
Ein Ausweg aus diesen Problemen versprechen die neuen Möglichkeiten aus dem Gebiet des automatischen Differenzierens. Durch die stetige Erhöhung der Rechenleistung von Computern und die neuen Anwendungsmöglichkeiten im Bereich der künstlichen Intelligenz konnten hier in den letzten Jahren viele Verbesserungen erreicht werden.\\
Mit dem automatischen Differenzieren ist es möglich, Computerprogramme abzuleiten, also Jacobi-, Hessematrix etc. für Programmme zu bestimmen. Die Idee hinter diesem Projekt ist es nun, die Fortschritte in diesem Bereich zu nutzen und auf das dargestellte Problem der Parameteridentifikation von Hysteresemodellen anzuwenden.
\subsection{Vorgehen}
Als Beispielmodell wird das Jiles-Atherton-Modell verwendet, da es relativ populär ist und somit viele Erfahrungswerte in der wissenschaftlichen Literatur vorhanden sind. Außerdem hat es eine recht kleine Parameteranzahl, was einige Vereinfachungen mit sich bringt. Dieses Modell wird in Abschnitt \ref{sec:jiles-atherton} genauer dargestellt.\\
\paragraph{Skalares Vorwärtsmodell} Der nächste Schritt ist, das Vorwärtsmodell für den skalaren Fall (keine Ortsauflösung von Feld und Hysterese) zu entwerfen. Dieses Vorwärtsmodell ist effektiv eine Abbildung vom Parameterraum in die Menge der Hysteresekurven -- für jede Parameterkombination erhält man eine (zeitlich diskretisierte) B-H-Kurve.
\paragraph{Integration} Dies wird durch die Integration der differentiellen Magnetisierung, die das Jiles-Atherton-Modell beschreibt, erreicht. Da die verfügbaren AD-Tools nicht mit den  integrierten Algorithmen der üblichen Mathematik-Pakete umgehen können, muss diese Integration manuell implementiert werden. Als Algorithmus wird zu Beginn ein Runge-Kutta-Verfahren gewählt, welches in einem Artikel als geeignet für das Jiles-Atherton-Modell beschrieben wurde. Eine kurze Übersicht zum Thema der numerischen Integration und den Runge-Kutta-Verfahren ist in Abschnitt \ref{sec:numeric-integration} gegeben.
\paragraph{Inverses Problem} Der nächste Schritt ist der Entwurf des inversen Problems: Gesucht ist nun das Urbild einer Hysteresekurve (Messung) im Parameterraum. Dazu wird zuerst eine Kostenfunktion aufgestellt, von der anschließend mit den Methoden des automatischen Differenzierens Jacobi- und Hessematrix ermittelt werden. Daraufhin wird die Kostenfunktion mit einem geeigneten Algorithmus minimiert. Dadurch erhält man die optimierten Parameter zur gegebenen Messkurve.\\
\paragraph{Ortsaufgelöstes Vorwärtsmodell}
Die bisherigen Berechnungen galten stets für ein skalares Modell, der Kern wurde also betrachtet als würde in jedem Punkt das gleiche Feld herrschen. Dies ist jedoch natürlich nur eine Näherung. Daher soll im nächsten Schritt das Jiles-Atherton-Modell auf einen ausgedehnten Kern übertragen werden. Die Zeitdiskretisierung wird genauso wie vorher mit finiten Differenzen (Runge-Kutta-Methode) vorgenommen, die Ortsdiskretisierung basiert auf der Finite-Elemente-Methode. Mit dem ortsaufgelösten Vorwärtsmodell kann nun die Hysterese im gesamten Kern ortsaufgelöst und unter Berücksichtigung der Maxwell-Gleichungen modelliert werden.
\paragraph{Inverses ortsaufgelöstes Problem}
Wie beim skalaren Modell gilt es nun, das inverse Problem zu implementieren. Hierfür wird abermals auf das Automatische Differenzieren zurückgegriffen -- in diesem Fall ist bei einem einzelnen Zeitschritt jedoch nicht eine einzelne Gleichung zu lösen, sondern ein ganzes FEM-Problem. Mit der Software \emph{dolfin-adjoint} kann jedoch die Differentiation von FEM-Modellen abstrahiert und so stark vereinfach werden. Die Kostenfunktion wird nun zu einem Kostenfunktional, also einer Funktion der Lösung der einzelnen FEM-Probleme aus den einzelnen Zeitschritten. Mit einem geeigneten Optimierungssalgorithmus kann nun abermals aus Messwerten auf die Parameter geschlossen werden.
\section{Jiles-Atherton-Modell}
\label{sec:jiles-atherton}
Das Jiles-Atherton-Modell ist ein physikalisch motiviertes Modell zur Beschreibung der Hysterese von magnetischen Materialien.
\subsection{Konstituierende Gleichungen}
\begin{align}
	\He &= H + \alpha M \quad &&\text{Effektives Feld} \label{eq:h_eff}\\
	\Man &= \Msat \Langevin\left(\frac{\He}{a}\right) \quad &&\text{Anhysterische Magnetisierung}  \label{eq:m_an}\\
	\frac{\dif\Mirr}{\dif \He} &= \frac{\Man - \Mirr}{k \sign\left(\frac{\dif H}{\dif t}\right)} \quad &&\text{Pinning} \label{eq:pinning}\\
	M &= \Mrev + \Mirr \quad &&\text{Gesamte Magnetisierung} \label{eq:m_gesamt}\\
	\Mrev &= c(\Man - \Mirr) \quad &&\text{Irreversible Magnetisierung} \label{eq:m_rev}
\end{align}
In diesen fünf Modellgleichungen kommen fünf Modellparameter vor:
\begin{labeling}{$\Msat$}
	\item[$\alpha$]{Interdomänenkopplung}
	\item[$a$]{Domänenwanddichte}
	\item[$\Msat$]{Sättigungsmagnetisierung}
	\item[$k$]{Pinning-Energie}
	\item[$c$]{Magnetisierungsreversibilität}
\end{labeling}
\subsection{Herleitung der Differentiale}
Ziel ist es nun, einen differentiellen Zusammenhang zwischen $M$ und $H$ zu finden. Dazu:
\begin{equation}
	M \underset{\textref{eq:m_gesamt}}{=} \Mrev + \Mirr \underset{\textref{eq:m_rev}}{=} c (\Man - \Mirr) + \Mirr = c\Man + (1-c)\Mirr.
\end{equation}
Es gilt also
\begin{equation}
	\dif M = (1-c) \dif\Mirr + c\dif \Man \label{eq:dm},
\end{equation}
weiterhin stimmt jeweils
\begin{align}
	\dif \Mirr &= \frac{\dif \Mirr}{\dif \He}\dif \He \\
	\dif \Man &= \frac{\dif \Man}{\dif \He}\dif \He\\
	\dif \He & \underset{\textref{eq:h_eff}}{=} \dif H + \alpha \dif M.
\end{align}
Man erhält nun für $\dif M$ zusammengefasst:
\begin{align}
	\begin{split}
		\dif M &\eqr{eq:dm} (1-c) \dif\Mirr + c\dif \Man \\
				&= (1-c) \frac{\dif \Mirr}{\dif \He}\dif \He + c \frac{\dif \Man}{\dif \He}\dif \He,
	\end{split}
\end{align}
in dieser Darstellung sind nun die aus den konstituierenden Gleichungen \ref{eq:m_an} und \ref{eq:pinning} leicht zugänglichen Größen $\dif \Mirr/\dif \He$ und $\dif \Man/\dif \He$ enthalten.
\begin{align}
	\Rightarrow \frac{\dif M}{\dif \He} &= (1-c) \frac{\dif \Mirr}{\dif \He} + c \frac{\dif \Man}{\dif \He} \label{eq:dm_dhe}
\end{align}
Abhängig von der Formulierung des elektrodynamischen Problems können nun zwei verschiedene Formulierungen gewählt werden.
\paragraph{Formulierung mit H-Feld}
Soll das Problem abhängig vom H-Feld gewählt werden, formuliert man $\dif \He$ wie folgt
\begin{equation}
	\dif \He \eqr{eq:h_eff} \dif H + \alpha \dif M,
\end{equation}
also
\begin{align}
	\dif M &= \frac{\dif M}{\dif \He} \dif \He \\
	&= \frac{\dif M}{\dif \He} \left(\dif H + \alpha \dif M\right) \\
	\Rightarrow \frac{\dif M}{\dif H} &= \frac{\dif M / \dif \He}{1 - \alpha \dif M /\dif \He}
\end{align}
\paragraph{Formulierung mit B-Feld} Bei der Formulierung mit der magnetischen Flussdichte formuliert man mit $B = \mu_0(H + M)$
\begin{align}
	\dif \He &= \frac{\dif B}{\mu_0} - \dif M + \alpha \dif M \\
		&= \frac{\dif B}{\mu_0} - (1 - \alpha) \dif M
\end{align}
Für $\dif M/\dif B$ erhält man nun
\begin{align}
	\dif M &= \frac{\dif M}{\dif \He} \dif \He \\
	&=\frac{\dif M}{\dif \He}\left(\frac{\dif B}{\mu_0} - (1 - \alpha) \dif M\right) \\
	\Rightarrow \frac{\dif M}{\dif B} &= \frac{1}{\mu_0}\frac{\dif M/\dif \He}{1 + (1-\alpha) \dif M/\dif \He}
\end{align}
\subsection{Abhängigkeiten}
Die differentielle Magnetisierung ist, wenn man alle Terme ausschreibt, abhängig von $H$, $M$, $\dif H/\dif t$ und dem Parametervektor $\vec{p} = (\alpha, a, \Msat, k, c)^T$:
\begin{equation}
	\frac{\dif M}{\dif H} = \frac{\dif M}{\dif H}\left(H, M, \frac{\dif H}{\dif t}, \vec p \right)
\end{equation}
\section{Numerische Integration}
\label{sec:numeric-integration}
Das Jiles-Atherton-Modell beschreibt -- wie oben gezeigt -- die differentielle Magnetisierung $\dif M /\dif H$. Um Aussagen über den zeitlichen Verlauf der Magnetisierung und somit über die Kernverluste zu gewinnen, muss diese differentielle Magnetisierung integriert werden:
\begin{equation}
	M(H) = \int \frac{\dif M}{\dif H}\dif H + \text{const.}
\end{equation}
beziehungsweise, in zeitabhängiger Formulierung
\begin{equation}
	M(t) = \int \frac{\dif M}{\dif H}\frac{\dif H}{\dif t}\dif t + \text{const.}
\end{equation}
Diese Integration ist analytisch nicht zugänglich und muss numerisch ausgeführt werden. Man verwendet hierfür typischerweise integrierte Lösungen wie den Solver \emph{ode45} in Matlab oder das Python-Äquivalent \emph{scipy.integrate.ode}. Diese Methoden implementieren die üblichen Multistep-Verfahren, explizit das Runge-Kutta-Fehlberg-Verfahren. Dieses ist eine Variante des klassischen Runge-Kutta-Verfahrens mit adaptiver Schrittweite.\\
Da im Nachfolgenden jedoch das Ergebnis einer solchen Integration nach dem Parametervektor $\vec p$ differenziert werden soll, benötigt man eine Integrationsmethode, die den Werkzeugen der Automatischen Differentiation zugänglich ist. Aus diesem Grund muss die Integration direkt implementiert werden.
\subsection{Explizites Euler-Verfahren}
Das einfachste Integrationsverfahren ist das explizite Euler-Verfahren (Forward-Euler, Polygonzugverfahren), es entspricht dem einfachsten expliziten Finite-Differenzen-Ansatz:
\begin{equation}
\begin{aligned}
	\frac{\dif y}{\dif t} &= f(y, t)\\[0.5cm]
	\Rightarrow	\quad \frac{y_{n} - y_{n-1}}{t_{n} - t_{n-1}} &\approx f(y_{n-1}, t_{n-1})
\end{aligned}
\end{equation}
So erhält man für den jeweils nächsten Zeitschritt
\begin{equation}
	y_n \approx y_{n-1} + f(y_{n-1}, t_{n-1})(t_n - t_{n-1})
\end{equation}
\subsection{Implizites Euler-Verfahren}
Im vorherigen Abschnitt wurde ein explizites Verfahren gewählt, d.h. die Funktion $f(y,t)$ wurde durch bereit bekannte Werte von $y$ und $t$ angenähert, $f(y, t) \approx f(y_{n-1}, t_{n-1})$. Alternativ kann man auch einen impliziten Ansatz wählen, $f(y, t) \approx f(y_n, t_n)$, dann erhält man eine implizite Gleichung für den nächsten Zeitschritt
\begin{equation}
	y_n = y_{n-1} + f(y_n, t_n)(t_n - t_{n-1}).
\end{equation}
Diese Gleichung ist jedoch -- da sie implizit und im Allgemeinen nichtlinear ist -- ungleich schwerer zu lösen als die explizite, man benötigt hier üblicherweise numerische Methoden wie die Fixpunktiteration oder etwa, falls der Gradient vorhanden ist, das Newton-Verfahren.\\
Der erhöhte Rechenaufwand der impliziten Verfahren wird durch eine erhöhte Stabilität ausgeglichen, insbesondere bei der Problemklasse der steifen Probleme.\\
Die Integration des Jiles-Atherton-Modells stellt jedoch keine hohen Anforderungen an die Stabilität, wodurch explizite Verfahren verwendet werden können.
\subsection{Kurzer Vergleich}
Der Nachteil von diesen einfachen Verfahren ist ihre geringe Genauigkeit, bzw. die sehr kleine Schrittweite und somit der erhöhte Rechenaufwand, welche man wählen muss, um eine ausreichende Genauigkeit zu erhalten. Als Beispiel soll nun die wohl einfachste Differentialgleichung
\begin{equation}
	\frac{\dif y}{\dif t} = y(t), \quad y(0) = 1 \label{eq:ode}
\end{equation}
mit der Lösung $y(t) = \E^t$ betrachtet werden.\\
\begin{figure}
\fcapside[\FBwidth]{
\caption{Vergleich von einfachen numerischen Integrationsverfahren (vgl. ODE \ref{eq:ode}). Die durchgezogene Linie ist die exakte Lösung, gepunktet sieht man das Resultat des expliziten Euler-Verfahrens, das implizite Verfahren ist gestrichelt dargestellt. Die vertikalen Gitterlinien beschreiben die diskretisierten Zeiten.}
\label{fig:euler}
}{
	\begin{mplibcode}
input graph;
beginfig(1);
	lx := 0.5*\mpdim{\textwidth};
	ly := 0.5*lx;
	sp := 0.5mm;
	draw begingraph(lx,ly);
	setcoords(linear, linear);
	setrange((0.0, 0.0), 1.1, 3.9);
	
	for y=1 step 1 until 3.5:
   	grid.lft(textext("\footnotesize\num[round-mode = places, round-precision=1]{" & decimal y & "}"), y) withcolor .7white;
	endfor;
	
	for y=0 step 0.2 until 1:
   	grid.bot(textext("\footnotesize\num[round-mode = places, round-precision=1]{" & decimal y & "}"), y) withcolor .7white;
	endfor;
	
	pickup pencircle scaled 0.5bp;    gdraw "../scripts/data/euler_analytic.txt";    gdraw "../scripts/data/euler_explicit.txt" dashed dashpattern(on 0.1bp off 2bp);    gdraw "../scripts/data/euler_implicit.txt" dashed evenly;
	
	pickup pencircle scaled 0.5bp; 
	frame.llft;    endgraph;
	drawarrow (-sp,0) -- (lx, 0);
	drawarrow (0,-sp) -- (0, ly);
	path bounds;
	bounds := (0, 0) -- (xpart lrcorner currentpicture, 0) -- urcorner currentpicture --(0, ypart ulcorner currentpicture) -- cycle;
	setbounds currentpicture to bounds;
	endfig; 
\end{mplibcode}}
\vspace{0.5cm} 
\end{figure}%
Wie man in Abbildung \ref{fig:euler} erkennt, akkumulieren sich in beiden Verfahren (bei großer Schrittweite) schnell große Fehler. Das explizite Verfahren nutzt die Steigung im aktuellen Punkt für den nächsten Schritt, unterschätzt bei der $\E$-Funktion also stets die Steigung, während das implizite Verfahren jeweils die Steigung im nächsten Punkt als Näherung verwendet. Die führt in diesem Fall jeweils zu einer Überschätzung der Steigung.\par
Um die Schrittweise nicht zu klein wählen zu müssen und somit den Rechenaufwand zu reduzieren, wurden viele verschiedene Integrationsverfahren entworfen. Die meisten sind Einschritt-Verfahren, wie etwa die Runge-Kutta-Methoden -- für den nächsten Zeitschritt werden dabei jedoch Zwischenschritte berechnet, die die Näherung verbessern. Man erhöht so zwar den Aufwand für einen einzelnen Schritt, kann aber dafür die Schrittweite deutlich größer wählen.\\
Eine weitere Möglichkeit, den Rechenaufwand zu reduzieren ist eine adaptive Schrittweitensteuerung: Man schätzt mit einem weiteren Zwischenschritt den Fehler und kann so die Schrittweite jeweils so groß wie möglich wählen (vgl. Runge-Kutta-Fehlberg-Methode).\\
Die Wahl des richtigen Algorithmus ist stets vom genauen Problem abhängig, für die vorliegende Integration des Jiles-Atherton-Modells eignet sich laut \cite{ja-rk} jedoch der viel verwendete RK4-Algorithmus mit fester Schrittweite.
\subsection{Runge-Kutta-Methoden}
Die Euler-Verfahren sind Sonderfälle der Runge-Kutta-Methoden, welche eine wichtige Klasse von Einschrittverfahren darstellen. Der m-stufige Algorithmus benötigt Gewichte $\alpha_i, \gamma_i, 1 \le i \le m$ und $\beta_{i,l}, 1\le i, l\le m$. Weiterhin müssen die Schrittweiten  $h_i$ vorgegeben werden, zur Vereinfachung soll jedoch eine feste Schrittweite $h$ angenommen werden.\\
Für den nächsten Datenpunkt berechnet man:
\begin{equation}
\begin{aligned}
	\text{Nächster Zeitpunkt} && t_n &= t_{n-1} + h \\
	\text{i-ter Hilfswert} && k_i &= f\left(y_{n-1} + h \sum_{l=1}^m \beta_{i,l}k_l, t_{n-1} + \alpha_i h\right) \\
	\text{Nächster Wert} && y_n &= y_{n-1} + h\sum_{l=1}^m y_l k_l
\end{aligned}
\end{equation}
Die Gewichte werden meist in einem sogenannten Butcher-Tableau dargestellt
\begin{equation*}
	\begin{array}{c|ccc}
	\alpha_1 	& \beta_{1,1}   & \cdots & \beta_{1,m} \\
	\alpha_2 	& \beta_{2,1}   & \cdots & \beta_{2,m} \\
	\vdots      & \vdots        & \ddots & \vdots        \\
	\alpha_m    & \beta_{m,1}   & \cdots & \beta_{m,m} \\
	\hline
	            & \gamma_1      & \cdots & \gamma_m
\end{array}.
\end{equation*}
Die entstehenden Gleichungen für die Hilfswerte $k_i$ sind im Allgemeinen implizit, es entsteht also ein nichtlineares Gleichungssystem. Sind jedoch die Werte $k_i$ nur von schon vorher berechneten Werten $k_j, j < i$ abhängig, entsteht ein explizites Verfahren. Die Koeffizienten $\beta_{i,l}$ lassen sich im Butcher-Tableau nun als untere Dreiecksmatrix anordnen. Das klassische Runge-Kutta-Verfahren (RK4) hat beispielsweise das Tableau
\begin{equation}
\renewcommand\arraystretch{1.2}
\begin{array}{c|cccc}
	0 &&&& \\
	\tfrac{1}{2} & \tfrac{1}{2} &&& \\
	\tfrac{1}{2} & 0 & \tfrac{1}{2} && \\
	1 & 0 & 0 & 1 &\\
	\hline
	& \tfrac{1}{6} & \tfrac{1}{3} & \tfrac{1}{3} & \tfrac{1}{6}
\end{array}
\end{equation}
Schreibt man für dieses die einzelnen Schritte aus, so ist die Berechnung des nächsten Wertes im RK4-Verfahren:
\begin{equation}
	\begin{aligned}
		t_n &= t_{n-1} + h \\[0.3cm]
		k_1 &= f\left(y_{n-1}, t_{n-1}\right) \\
		k_2 &= f\left(y_{n-1} + hk_1/2, t_{n-1} + h/2\right) \\
		k_3 &= f\left(y_{n-1} + hk_2/2, t_{n-1} + h/2\right) \\
		k_4 &= f\left(y_{n-1} + hk_3, t_{n-1} + h\right) \\[0.3cm]
		y_n &= y_{n-1} + \tfrac{h}{6}\left(k_1 + 2k_2 + 2k_3 + k_4 \right)
	\end{aligned}
\end{equation}
\newpage
\printbibliography
\end{document}